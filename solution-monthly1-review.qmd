---
title: "Review"
---

This is meant as a review of the most used functions for the 4-day traning.

## Setup

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(janitor)
library(scales)
```


## The data

Domestic box office daily revenue as tracked by [Box Office Mojo](https://www.boxofficemojo.com/) as scraped collected by Tom Waterman in this Github repository [boxofficemojo-scraper](https://github.com/tjwaterman99/boxofficemojo-scraper).

## The questions

A list of things we'll try to answer with this data:

- Title with highest revenue single day
- Titles in the most theaters on a single day
- Title appearing the most
- Title with highest revenue since 2000
- Distributor with the most revenue since 2000
- Industry revenue by year (i.e., the COVID effect)
- Highest grossing movies this year

## Download the data

This downloads the file into the local folder. Since the data is updated daily, you can uncomment and run this to get the most recent data. You'll definitely need to do that at least once.

```{r}
# download.file("https://github.com/tjwaterman99/boxofficemojo-scraper/releases/latest/download/revenues_per_day.csv.gz", "data-raw/revenues_per_day.csv.gz", mode = "wb")
```

## Import

We use the tidyverse `read_csv()` here because it is better than `read.csv()`. We don't use the `clean_names()` function because we don't need it.

```{r}
raw <- read_csv("data-raw/revenues_per_day.csv.gz")

raw |> head()
```

## Using select and arrange

I'm noticing the above data starts in October of 2002. It might make sense to sort this data in a logical way, and also remove the unnecessary `id` column.

Here we use `select()` to remove the `id` variable and then `arrange()` the data by the most recent date in descending order, and then the movie that is in the most theaters.

We use the `desc()` function two different ways here for no reason other than to show you there are two ways. Choose the method that works best for you.

```{r}
boxoffice <- raw |>
  select(!id) |>
  arrange(date |> desc(), desc(theaters))
```

Note since we saved that result into a new object, nothing gets printed onto our notebook.

So ... we use `head()` to peek at the top of the list.

```{r}
boxoffice |> head()
```

We can also use `summary()` to getsome summary statistics of our data

```{r}
boxoffice |> summary()
```

This is an important look because it shows us that we have data from Jan. 1, 2020. The end date depends on when you download the data!

Lastly we use `glimpse()` so we can see all the variables and datatypes at one time.

```{r}
boxoffice |> glimpse()
```

## Just sorting

Some answers we can find by just sorting our data in specific ways.

### Title with highest revenue single day

Since each row is a movie's take for that day, we just need to arrange by revenue in descending order.

```{r}
boxoffice |>
  arrange(revenue |> desc()) |> 
  filter(revenue >= 90000000 ) # here we filter just to cut off the list.
```

Apparently there is a reason they make super hero movies.

### Titles in the most theaters on a single day

```{r}
boxoffice |> 
  arrange(desc(theaters)) |> 
  filter(theaters > 4500)
```

Perhaps those movies make more because they are in more theaters. Maybe we can get into that.

## Group and count

Let's look at things we can just count. The concept here is to use `group_by()` to put our data into piles (or groups) based on the values in a column, then count how many their are.

### Title appearing the most

Here we we group by the title of the movies, and then count the **n**umber of rows in that group using `n()`. We arrange the result to show the most appearances at the top. At the end we filter the result at a logical place, You can remove that if you want to see more rows.

```{r}
boxoffice |>
  group_by(title) |> 
  summarise(appearances = n()) |> 
  arrange(desc(appearances)) |> 
  filter(appearances > 150)
```

Here we grouped by title to count how many times is what in the data, but what if a different distributor released the same movie? You could try adding `distributor` to the group and see how the results change, including the numbers of rows returned. Does that matter? I'm not sure ... you'd need to look further and probably do some reporting.

## Group and sum

In many cases we want to put our data into groups and the do some [useful math](https://dplyr.tidyverse.org/reference/summarise.html#useful-functions) on variables, like `sum()` or `mean()`.

### Title with highest revenue over time

Now we are grouping our data by the title of the movie, then use `summarize()` and `sum()` to add up the revenue for each title. At the end we are just filtering the list to cut it off at a logical value.

```{r}
boxoffice |> 
  group_by(title) |> 
  summarise(total_rev = sum(revenue)) |> 
  arrange(desc(total_rev)) |> 
  filter(total_rev >= 300000000)
```

Wow ... go Barbie.

### OYO: Distributor most revenue

I don't know that movie fans care, but entertainment reporters might want to know which movie distributor has made the most? How would you find that?

```{r}
boxoffice |> 
  group_by(distributor) |> 
  summarise(total_rev = sum(revenue)) |> 
  arrange(desc(total_rev))
```

## Using mutate to parse a date

Let's create a version of this data that makes it easier to group by month and year. We use `mutate()` to create or change data, and inside of it we'll create some new variables using functions from [lubridate](https://lubridate.tidyverse.org/) to get date parts.

This is chunk is built sort of like a machine ... We create a new bucket for our data `boxoffice_dates` and then we fill using our original boxoffice data with it's mutations. At the end we use `glimpse()` on the new data so we can make sure our new variables worked the way we intended.

To be clear, this is something you do a line or two at a time, checking the result as you go along. It's easier demonstrate live.

```{r}
boxoffice_dates <- boxoffice |> 
  mutate(
    yr = year(date), # the year
    mo = month(date, label = TRUE), # an ordered month
    fl_mo = floor_date(date, unit = "month") # a floor month
  )

boxoffice_dates |> glimpse()
```

To explain what is going on:

- Creating the year above is pretty self explanitory: Pluck the year from the date and call it `yr`.
- The next value `mo` is plucking the month from the year, but in a special way. We are creating a short month name that understands that "Jan" comes before "Feb" and both are before the alphabetical "Apr". This data type is called an "ordered factor", hence the datatype above being `<ord>`. It will become useful with charting by month of the year.
- The last values `fl_mo` uses the function `floor_date()` to find the lowest values of a given unit of time (floor being lower than the ceiling). We choose `unit = "month") so we get the first day of the month. This is useful because it is still an actual date, which can again help with plots.


## Group and summarize by dates

### Revenue per year

```{r}
yr_revenue <- boxoffice_dates |> 
  group_by(yr) |> 
  summarize(yearly_rev = sum(revenue))

yr_revenue
```

Again, we save our summarization into a new object called `yr_revenue` and then print it out.

Now we can chart that:

```{r}
yr_revenue |> 
  ggplot(aes(x = yr, y = yearly_rev)) +
  geom_col() +
  scale_y_continuous(labels = label_dollar(scale_cut = cut_short_scale())) +
  labs (
    title = "Box office revenue by year",
    caption = "Source: Box Office Mojo",
    x = "", y = "Yearly revenue"
  ) +
  theme_minimal()
```

It was the first three lines above that gave you the visual. The others make that Y scale more readable and add (or remove) nice labels.

### Total revenues by month

Some hints on this:

- Use the fl_mo to group and sum the revenue
- Plot by the fl_mo and summed revenue
- You might try geom_line?

The data:

```{r}
mo_revenue <- boxoffice_dates |> 
  group_by(fl_mo) |> 
  summarise(monthly_revenue = sum(revenue))

mo_revenue
```

The plot:

```{r}
mo_revenue |> 
  ggplot(aes(x = fl_mo, y = monthly_revenue)) +
  geom_line()
```

This look shows some seasonality but it is hard to see here. Two things we might consider: a) to summarize totals or mean by month, or b) use facet_wrap to show the last few years.

### Highest grossing movies this year

Highest grossing movies in 2023

```{r}
boxoffice |> 
  filter(year(date) == 2023) |> 
  group_by(title) |> 
  summarise(total_rev = sum(revenue)) |> 
  arrange(desc(total_rev))

```

### What about the Taylor Era?

OK, my students are obsessed with Taylor Swift. How is her moving doing vs the competition? Let's look at revenues since October.

Find the receipts since October 2023.

```{r}
bo_recent <- boxoffice |> 
  filter(
    date >= "2023-10-01"
  ) |> 
  arrange(revenue |> desc()) |> 
  filter(revenue >= 2000000)

bo_recent
```

Show the plot

```{r}
bo_recent |> 
  ggplot(aes(x = date, y = revenue, color = title)) +
  geom_line() +
  scale_y_continuous(
    labels = label_dollar(scale_cut = cut_long_scale()),
    limits = c(0,40000000)
  ) +
  scale_x_date(minor_breaks = breaks_width("1 week")) +
  labs(
    title = "Movie revenue since October 2023",
    x = "", color = "Title"
  )


```


## More on your own challenges

### Revenue by day for your favorite movie

How might you go about this?

1. Filter the date to find your favorite movie.
2. Plot the date along the x axis and revenue along the y axis.

```{r}
boxoffice |> 
  filter(str_detect(title, "The Fellowship of the Ring")) |> 
  ggplot(aes(x = date, y = revenue)) +
  geom_point(alpha = 0.23) +
  scale_y_continuous(labels = label_dollar(scale_cut = cut_long_scale())) +
  labs(
    title = "The Fellowship of the Ring"
  )
```

### Revenue by month over time

The idea here is to show the summer blockbuster season and holiday bumps.

1. Summarize the date by your ordered month. Get the sum or mean (or both!)
2. Plot the results

```{r}
bo_by_mo <- boxoffice_dates |> 
  group_by(mo) |> 
  summarize(monthly_total = sum(revenue),
            monthly_mean = mean(revenue))

bo_by_mo
```

Plot the totals

```{r}
bo_by_mo |> 
  ggplot(aes(x = mo, y = monthly_total)) +
  geom_col() +
  scale_y_continuous(labels = label_dollar(scale_cut = cut_short_scale()))

```

Plot the averages

```{r}
bo_by_mo |> 
  ggplot(aes(x = mo, y = monthly_mean)) +
  geom_col()
```

These two look are roughly the same, which is perhaps not surprising over 23 years.

### Revenue by YTD

You could calculate the year to date with `yday()` and plot across all years on that date. That would sho 366 values with the amount brought in those days.

```{r}
bo_by_ytd <- boxoffice_dates |> 
  group_by(ytd = yday(date)) |> 
  summarize(ytd_total = sum(revenue))

bo_by_ytd
```

```{r}
bo_by_ytd |> 
  ggplot(aes(x = ytd, y = ytd_total)) +
  geom_line() +
  scale_y_continuous(labels = label_dollar(scale_cut = cut_short_scale()))

```

## Other looks

### Summer blockbusters in 2023

Here we are looking at just the revenue from movies during the summer of 2023.

The only new thing here is within a filter we are using the lubridate function `month()` to pull the numerical value of the date to use in the filter as a range, May (5) through August (8).

```{r}
boxoffice_dates |> 
  filter(
    yr == 2023,
    month(date) == 5:8
  ) |> 
  group_by(title) |> 
  summarise(total_rev = sum(revenue)) |> 
  arrange(total_rev |> desc())
```

### Revenue per theater

This might be stupid, but I wondered if it was worth looking at the 'revenue per theater" to figure out the most expensive movies to see.

First We calculate revenue per theater.

```{r}
bo_rev <- boxoffice |> 
  mutate(rev_per_theater = (revenue / theaters) |> round(2))

bo_rev |> glimpse()
```

The we sort by day with the highest revenues per theater:

```{r}
bo_rev |> 
  arrange(rev_per_theater |> desc())
```

There is some unusual answers at the top that must be errors or odd occurances. Let's do this only where the movie was in more than 100 theaters:

```{r}
bo_rev |> 
  arrange(rev_per_theater |> desc()) |> 
  filter(
    theaters >= 100,
    rev_per_theater > 20000
  )
```

